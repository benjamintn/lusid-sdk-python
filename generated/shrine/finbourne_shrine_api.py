# coding=utf-8
# --------------------------------------------------------------------------
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is
# regenerated.
# --------------------------------------------------------------------------

from msrest.service_client import ServiceClient
from msrest import Configuration, Serializer, Deserializer
from .version import VERSION
from msrest.pipeline import ClientRawResponse
from msrest.exceptions import HttpOperationError
from . import models


class FINBOURNEShrineAPIConfiguration(Configuration):
    """Configuration for FINBOURNEShrineAPI
    Note that all parameters used to create this instance are saved as instance
    attributes.

    :param str base_url: Service URL
    """

    def __init__(
            self, base_url=None):

        if not base_url:
            base_url = 'http://localhost'

        super(FINBOURNEShrineAPIConfiguration, self).__init__(base_url)

        self.add_user_agent('finbourneshrineapi/{}'.format(VERSION))


class FINBOURNEShrineAPI(object):
    """FINBOURNEShrineAPI

    :ivar config: Configuration for client.
    :vartype config: FINBOURNEShrineAPIConfiguration

    :param str base_url: Service URL
    """

    def __init__(
            self, base_url=None):

        self.config = FINBOURNEShrineAPIConfiguration(base_url)
        self._client = ServiceClient(None, self.config)

        client_models = {k: v for k, v in models.__dict__.items() if isinstance(v, type)}
        self.api_version = 'v0'
        self._serialize = Serializer(client_models)
        self._deserialize = Deserializer(client_models)


    def api_me_get(
            self, applications=None, as_at=None, sort_by=None, start=None, limit=None, filter=None, custom_headers=None, raw=False, **operation_config):
        """GetOwnPolicies.

        Gets all Policies for the current user.

        :param applications: Optional. Filter on the applications that the
         policies apply to
        :type applications: list[str]
        :param as_at: Optional. The AsAt date time of the data
        :type as_at: datetime
        :param sort_by: Optional. Order the results by these fields. Use use
         the '-' sign to denote descending order e.g. -MyFieldName
        :type sort_by: list[str]
        :param start: Optional. When paginating, skip this number of results
        :type start: int
        :param limit: Optional. When paginating, limit the number of returned
         results to this many.
        :type limit: int
        :param filter: Optional. Expression to filter the result set
        :type filter: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~shrine.models.AttachedPolicyDefinitionResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.api_me_get.metadata['url']

        # Construct parameters
        query_parameters = {}
        if applications is not None:
            query_parameters['applications'] = self._serialize.query("applications", applications, '[str]', div=',')
        if as_at is not None:
            query_parameters['asAt'] = self._serialize.query("as_at", as_at, 'iso-8601')
        if sort_by is not None:
            query_parameters['sortBy'] = self._serialize.query("sort_by", sort_by, '[str]', div=',')
        if start is not None:
            query_parameters['start'] = self._serialize.query("start", start, 'int')
        if limit is not None:
            query_parameters['limit'] = self._serialize.query("limit", limit, 'int')
        if filter is not None:
            query_parameters['filter'] = self._serialize.query("filter", filter, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[AttachedPolicyDefinitionResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    api_me_get.metadata = {'url': '/api/me'}

    def api_me_post(
            self, evaluations, applications=None, as_at=None, custom_headers=None, raw=False, **operation_config):
        """Evaluate.

        Given a dictionary of evaluation requests (keyed by any arbitrary
        correlation identifier), each will be evaluated according to the
        current user's policies (deduced from the provided OAuth token).

        :param evaluations: A dictionary of evaluations, keyed using any
         arbitrary correlation id (it will be returned with the response for
         that evaluation).
        :type evaluations: dict[str, ~shrine.models.EvaluationRequest]
        :param applications: Optional. The application type of the roles and
         policies to use when evaluating.
        :type applications: list[str]
        :param as_at: Optional. The requested AsAt date of the entitlements
        :type as_at: datetime
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: dict or ClientRawResponse if raw=true
        :rtype: dict[str, ~shrine.models.EvaluationResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.api_me_post.metadata['url']

        # Construct parameters
        query_parameters = {}
        if applications is not None:
            query_parameters['applications'] = self._serialize.query("applications", applications, '[str]', div=',')
        if as_at is not None:
            query_parameters['asAt'] = self._serialize.query("as_at", as_at, 'iso-8601')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json-patch+json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(evaluations, '{EvaluationRequest}')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('{EvaluationResponse}', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    api_me_post.metadata = {'url': '/api/me'}

    def api_policies_get(
            self, scope=None, as_at=None, sort_by=None, start=None, limit=None, filter=None, custom_headers=None, raw=False, **operation_config):
        """ListPolicies.

        Gets all Policies in a scope.

        :param scope: Optional. Will use the default scope if not provided.
         The requested scope
        :type scope: str
        :param as_at: Optional. The AsAt date time of the data
        :type as_at: datetime
        :param sort_by: Optional. Order the results by these fields. Use use
         the '-' sign to denote descending order e.g. -MyFieldName
        :type sort_by: list[str]
        :param start: Optional. When paginating, skip this number of results
        :type start: int
        :param limit: Optional. When paginating, limit the number of returned
         results to this many.
        :type limit: int
        :param filter: Optional. Expression to filter the result set
        :type filter: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~shrine.models.PolicyResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.api_policies_get.metadata['url']

        # Construct parameters
        query_parameters = {}
        if scope is not None:
            query_parameters['scope'] = self._serialize.query("scope", scope, 'str')
        if as_at is not None:
            query_parameters['asAt'] = self._serialize.query("as_at", as_at, 'iso-8601')
        if sort_by is not None:
            query_parameters['sortBy'] = self._serialize.query("sort_by", sort_by, '[str]', div=',')
        if start is not None:
            query_parameters['start'] = self._serialize.query("start", start, 'int')
        if limit is not None:
            query_parameters['limit'] = self._serialize.query("limit", limit, 'int')
        if filter is not None:
            query_parameters['filter'] = self._serialize.query("filter", filter, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[PolicyResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    api_policies_get.metadata = {'url': '/api/policies'}

    def api_policies_post(
            self, creation, custom_headers=None, raw=False, **operation_config):
        """CreatePolicy.

        Creates a Policy.

        :param creation: The definition of the Policy
        :type creation: ~shrine.models.PolicyCreationRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: PolicyResponse or ClientRawResponse if raw=true
        :rtype: ~shrine.models.PolicyResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.api_policies_post.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json-patch+json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(creation, 'PolicyCreationRequest')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('PolicyResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    api_policies_post.metadata = {'url': '/api/policies'}

    def api_policies_by_code_get(
            self, code, as_at=None, scope=None, custom_headers=None, raw=False, **operation_config):
        """GetPolicy.

        Gets an identified Policy.

        :param code: The code of the Policy
        :type code: str
        :param as_at: Optional. The AsAt date time of the data
        :type as_at: datetime
        :param scope: Optional. Will use the default scope if not provided.
         The scope of the Policy
        :type scope: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: PolicyResponse or ClientRawResponse if raw=true
        :rtype: ~shrine.models.PolicyResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.api_policies_by_code_get.metadata['url']
        path_format_arguments = {
            'code': self._serialize.url("code", code, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if as_at is not None:
            query_parameters['asAt'] = self._serialize.query("as_at", as_at, 'iso-8601')
        if scope is not None:
            query_parameters['scope'] = self._serialize.query("scope", scope, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('PolicyResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    api_policies_by_code_get.metadata = {'url': '/api/policies/{code}'}

    def api_policies_by_code_put(
            self, code, update, scope=None, custom_headers=None, raw=False, **operation_config):
        """UpdatePolicy.

        Updates a Policy.

        :param code: The code of the Policy
        :type code: str
        :param update: The updated definition of the Policy
        :type update: ~shrine.models.PolicyUpdateRequest
        :param scope: Optional. Will use the default scope if not provided.
         The scope of the Policy
        :type scope: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: PolicyResponse or ClientRawResponse if raw=true
        :rtype: ~shrine.models.PolicyResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.api_policies_by_code_put.metadata['url']
        path_format_arguments = {
            'code': self._serialize.url("code", code, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if scope is not None:
            query_parameters['scope'] = self._serialize.query("scope", scope, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json-patch+json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(update, 'PolicyUpdateRequest')

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('PolicyResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    api_policies_by_code_put.metadata = {'url': '/api/policies/{code}'}

    def api_policies_by_code_delete(
            self, code, scope=None, custom_headers=None, raw=False, **operation_config):
        """DeletePolicy.

        Deletes an identified Policy.

        :param code: The code of the Policy
        :type code: str
        :param scope: Optional. Will use the default scope if not provided.
         The scope of the Policy
        :type scope: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.api_policies_by_code_delete.metadata['url']
        path_format_arguments = {
            'code': self._serialize.url("code", code, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if scope is not None:
            query_parameters['scope'] = self._serialize.query("scope", scope, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    api_policies_by_code_delete.metadata = {'url': '/api/policies/{code}'}

    def api_policycollections_get(
            self, scope=None, as_at=None, sort_by=None, start=None, limit=None, filter=None, custom_headers=None, raw=False, **operation_config):
        """ListPolicyCollections.

        Gets all PolicyCollections in a scope.

        :param scope: Optional. Will use the default scope if not provided.
         The requested scope
        :type scope: str
        :param as_at: Optional. The AsAt date time of the data
        :type as_at: datetime
        :param sort_by: Optional. Order the results by these fields. Use use
         the '-' sign to denote descending order e.g. -MyFieldName
        :type sort_by: list[str]
        :param start: Optional. When paginating, skip this number of results
        :type start: int
        :param limit: Optional. When paginating, limit the number of returned
         results to this many.
        :type limit: int
        :param filter: Optional. Expression to filter the result set
        :type filter: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~shrine.models.PolicyCollectionResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.api_policycollections_get.metadata['url']

        # Construct parameters
        query_parameters = {}
        if scope is not None:
            query_parameters['scope'] = self._serialize.query("scope", scope, 'str')
        if as_at is not None:
            query_parameters['asAt'] = self._serialize.query("as_at", as_at, 'iso-8601')
        if sort_by is not None:
            query_parameters['sortBy'] = self._serialize.query("sort_by", sort_by, '[str]', div=',')
        if start is not None:
            query_parameters['start'] = self._serialize.query("start", start, 'int')
        if limit is not None:
            query_parameters['limit'] = self._serialize.query("limit", limit, 'int')
        if filter is not None:
            query_parameters['filter'] = self._serialize.query("filter", filter, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[PolicyCollectionResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    api_policycollections_get.metadata = {'url': '/api/policycollections'}

    def api_policycollections_post(
            self, creation, custom_headers=None, raw=False, **operation_config):
        """CreatePolicyCollection.

        Creates a PolicyCollection.

        :param creation: The definition of the PolicyCollection
        :type creation: ~shrine.models.PolicyCollectionCreationRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: PolicyCollectionResponse or ClientRawResponse if raw=true
        :rtype: ~shrine.models.PolicyCollectionResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.api_policycollections_post.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json-patch+json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(creation, 'PolicyCollectionCreationRequest')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('PolicyCollectionResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    api_policycollections_post.metadata = {'url': '/api/policycollections'}

    def api_policycollections_by_code_get(
            self, code, as_at=None, scope=None, custom_headers=None, raw=False, **operation_config):
        """GetPolicyCollection.

        Gets an identified PolicyCollection.

        :param code: The code of the PolicyCollection
        :type code: str
        :param as_at: Optional. The AsAt date time of the data
        :type as_at: datetime
        :param scope: Optional. Will use the default scope if not provided.
         The scope of the PolicyCollection
        :type scope: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: PolicyCollectionResponse or ClientRawResponse if raw=true
        :rtype: ~shrine.models.PolicyCollectionResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.api_policycollections_by_code_get.metadata['url']
        path_format_arguments = {
            'code': self._serialize.url("code", code, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if as_at is not None:
            query_parameters['asAt'] = self._serialize.query("as_at", as_at, 'iso-8601')
        if scope is not None:
            query_parameters['scope'] = self._serialize.query("scope", scope, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('PolicyCollectionResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    api_policycollections_by_code_get.metadata = {'url': '/api/policycollections/{code}'}

    def api_policycollections_by_code_put(
            self, code, update, scope=None, custom_headers=None, raw=False, **operation_config):
        """UpdatePolicyCollection.

        Updates a PolicyCollection.

        :param code: The code of the PolicyCollection
        :type code: str
        :param update: The updated definition of the PolicyCollection
        :type update: ~shrine.models.PolicyCollectionUpdateRequest
        :param scope: Optional. Will use the default scope if not provided.
         The scope of the PolicyCollection
        :type scope: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: PolicyCollectionResponse or ClientRawResponse if raw=true
        :rtype: ~shrine.models.PolicyCollectionResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.api_policycollections_by_code_put.metadata['url']
        path_format_arguments = {
            'code': self._serialize.url("code", code, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if scope is not None:
            query_parameters['scope'] = self._serialize.query("scope", scope, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json-patch+json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(update, 'PolicyCollectionUpdateRequest')

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('PolicyCollectionResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    api_policycollections_by_code_put.metadata = {'url': '/api/policycollections/{code}'}

    def api_policycollections_by_code_delete(
            self, code, scope=None, custom_headers=None, raw=False, **operation_config):
        """DeletePolicyCollection.

        Deletes an identified PolicyCollection.

        :param code: The code of the PolicyCollection
        :type code: str
        :param scope: Optional. Will use the default scope if not provided.
         The scope of the PolicyCollection
        :type scope: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.api_policycollections_by_code_delete.metadata['url']
        path_format_arguments = {
            'code': self._serialize.url("code", code, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if scope is not None:
            query_parameters['scope'] = self._serialize.query("scope", scope, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    api_policycollections_by_code_delete.metadata = {'url': '/api/policycollections/{code}'}

    def api_roles_get(
            self, scope=None, as_at=None, sort_by=None, start=None, limit=None, filter=None, custom_headers=None, raw=False, **operation_config):
        """ListRoles.

        Gets all Roles in a scope.

        :param scope: Optional. Will use all scopes if not supplied. The
         requested scope
        :type scope: str
        :param as_at: Optional. The AsAt date time of the data
        :type as_at: datetime
        :param sort_by: Optional. Order the results by these fields. Use use
         the '-' sign to denote descending order e.g. -MyFieldName
        :type sort_by: list[str]
        :param start: Optional. When paginating, skip this number of results
        :type start: int
        :param limit: Optional. When paginating, limit the number of returned
         results to this many.
        :type limit: int
        :param filter: Optional. Expression to filter the result set
        :type filter: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: list or ClientRawResponse if raw=true
        :rtype: list[~shrine.models.RoleResponse] or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.api_roles_get.metadata['url']

        # Construct parameters
        query_parameters = {}
        if scope is not None:
            query_parameters['scope'] = self._serialize.query("scope", scope, 'str')
        if as_at is not None:
            query_parameters['asAt'] = self._serialize.query("as_at", as_at, 'iso-8601')
        if sort_by is not None:
            query_parameters['sortBy'] = self._serialize.query("sort_by", sort_by, '[str]', div=',')
        if start is not None:
            query_parameters['start'] = self._serialize.query("start", start, 'int')
        if limit is not None:
            query_parameters['limit'] = self._serialize.query("limit", limit, 'int')
        if filter is not None:
            query_parameters['filter'] = self._serialize.query("filter", filter, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('[RoleResponse]', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    api_roles_get.metadata = {'url': '/api/roles'}

    def api_roles_post(
            self, creation, custom_headers=None, raw=False, **operation_config):
        """CreateRole.

        Creates a Role.

        :param creation: The definition of the Role
        :type creation: ~shrine.models.RoleCreationRequest
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: RoleResponse or ClientRawResponse if raw=true
        :rtype: ~shrine.models.RoleResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.api_roles_post.metadata['url']

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json-patch+json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(creation, 'RoleCreationRequest')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('RoleResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    api_roles_post.metadata = {'url': '/api/roles'}

    def api_roles_by_code_get(
            self, code, as_at=None, scope=None, custom_headers=None, raw=False, **operation_config):
        """GetRole.

        Gets an identified Role.

        :param code: The code of the Role
        :type code: str
        :param as_at: Optional. The AsAt date time of the data
        :type as_at: datetime
        :param scope: Optional. Will use default scope if not supplied. The
         scope of the Role
        :type scope: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: RoleResponse or ClientRawResponse if raw=true
        :rtype: ~shrine.models.RoleResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.api_roles_by_code_get.metadata['url']
        path_format_arguments = {
            'code': self._serialize.url("code", code, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if as_at is not None:
            query_parameters['asAt'] = self._serialize.query("as_at", as_at, 'iso-8601')
        if scope is not None:
            query_parameters['scope'] = self._serialize.query("scope", scope, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('RoleResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    api_roles_by_code_get.metadata = {'url': '/api/roles/{code}'}

    def api_roles_by_code_put(
            self, code, update, scope=None, before_scope=None, before_code=None, after_scope=None, after_code=None, custom_headers=None, raw=False, **operation_config):
        """UpdateRole.

        Updates a Role.

        :param code: The code of the Role
        :type code: str
        :param update: The updated definition of the Role
        :type update: ~shrine.models.RoleUpdateRequest
        :param scope: &gt;Optional. Will use default scope if not supplied.
         The scope of the Role
        :type scope: str
        :param before_scope: Optional. The scope of the Role. Will use default
         scope if not supplied.
        :type before_scope: str
        :param before_code: Optional. The code of the Role
        :type before_code: str
        :param after_scope: Optional. The scope of the Role. Will use default
         scope if not supplied.
        :type after_scope: str
        :param after_code: Optional. The code of the Role
        :type after_code: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: RoleResponse or ClientRawResponse if raw=true
        :rtype: ~shrine.models.RoleResponse or
         ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.api_roles_by_code_put.metadata['url']
        path_format_arguments = {
            'code': self._serialize.url("code", code, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if scope is not None:
            query_parameters['scope'] = self._serialize.query("scope", scope, 'str')
        if before_scope is not None:
            query_parameters['beforeScope'] = self._serialize.query("before_scope", before_scope, 'str')
        if before_code is not None:
            query_parameters['beforeCode'] = self._serialize.query("before_code", before_code, 'str')
        if after_scope is not None:
            query_parameters['afterScope'] = self._serialize.query("after_scope", after_scope, 'str')
        if after_code is not None:
            query_parameters['afterCode'] = self._serialize.query("after_code", after_code, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json-patch+json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(update, 'RoleUpdateRequest')

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, stream=False, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('RoleResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
    api_roles_by_code_put.metadata = {'url': '/api/roles/{code}'}

    def api_roles_by_code_delete(
            self, code, scope=None, custom_headers=None, raw=False, **operation_config):
        """DeleteRole.

        Deletes an identified Role.

        :param code: The code of the Role
        :type code: str
        :param scope: &gt;Optional. Will use default scope if not supplied.
         The scope of the Role
        :type scope: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or ClientRawResponse if raw=true
        :rtype: None or ~msrest.pipeline.ClientRawResponse
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = self.api_roles_by_code_delete.metadata['url']
        path_format_arguments = {
            'code': self._serialize.url("code", code, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if scope is not None:
            query_parameters['scope'] = self._serialize.query("scope", scope, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, stream=False, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response
    api_roles_by_code_delete.metadata = {'url': '/api/roles/{code}'}
